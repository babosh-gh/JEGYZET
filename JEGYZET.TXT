// Angular parancsok terminálba és fájlokba

// Angular kliens install:
npm install -g @angular/cli@17
npm install -g @angular/cli

//angular uninstall:
npm uninstall -g @angular/cli
npm uninstall -g angular/cli
npm cache verify
npm cache clean --force

// új angular projekt készítés:

ng new vizsga --no-standalone //ez
ng new vizsga

// cd vizsga után:
// új komponens a projekten belül:
ng g c vizsgafeladat

// ts install
npm install -g typescript
.ts fájlba írni
tsc filenév.ts -w


app.component.html - utolsó sort kivéve törölni mindent

// Bootstrap install és import
npm install bootstrap

// src / styles.css
@import "bootstrap/dist/css/bootstrap.css"; // ~ lehet kell a bootstrap szó elé.


// FormsModul import
// app.module.ts VAGY app.config.ts
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common'; // CommonModule importálása az *ngFor-hoz

FormsModule

//lehet, hogy a konkrét komponens.ts fájlba kell importálni:
@Component({ részben az imports tömbbe:

CommonModule, FormsModule




// ROUTING
// app-routing-module.ts
// app.routes.ts

const routes: Routes = [
  { path: "vizsgafeladat", component: VizsgafeladatComponent },//Ha beírom megoldás, akkor a vizsga megoldására ugrik
  { path: "", redirectTo: "/vizsgafeladat", pathMatch: "full" },//Ha üresen hagyom az útvonal nevét akkor is
  { path: "**", component: VizsgafeladatComponent }//Vagy ha bármi mást írok be akkor is
];


// kétirányú adatkötés aka INTERPOLÁCIÓ

// BACKEND RÉSZ - vizsgafeladat.component.ts

//backend részben mindent class-ba kell írni.
// a classon belül nem kell semmit külön deklarálni (let, var, function)
//változókat "this."-tal kell írni.


  suly: number = 1;
  magassag: number = 1;

  EredmenyMentes() {
    this.megoldasok.push(`Az ${this.suly}kg testsúlyó és ${this.magassag}m magasságú ember testtömeg indexe: ${this.suly / (this.magassag * this.magassag)}`)
  }
  megoldasok: string[] = [];


// FRONTEND RÉSZ -  vizsgafeladat.components.html
<div class="container">
    <h2>Angular modul megoldása</h2>
    <label for="sulyInput">Add meg a súlyod kilógrammban:</label>
    <input type="number" class="form-control" id="sulyInput" [(ngModel)]="suly">
    <label for="magassagInput">Add meg a magasságod méterben</label>
    <input type="number" class="form-control" id="magassagInput" [(ngModel)]="magassag">
    <button type="button" class="btn btn-success form-control mt-3" (click)="EredmenyMentes()">Eredmény mentése</button>
    <p>A megadott értékek alapján a testtömeg index: {{suly/(magassag*magassag)}}</p>

    <ul>
        <li *ngFor="let eredmenyek of megoldasok">
            {{eredmenyek}}
        </li>
    </ul>
</div>

van egy üres <ul>. benne csinálunk egy *ngFor-t, ami azt csinálja, hogy a vizsgált tömb (megoldasok) minden eleméhez csinál egy új <li> tagot, amibe belehelyezi a függvény eredményét.

//.ts fájlban
//minden class, interface külön exportot igényel.
// pl: export class <komponensneve> {
      //jöhet a kód
}
//  export interface turaSzakasz {
      //interface
}

// számtömbben minden elem megvizsgálása és egyedi elemek (vagy számuk) visszaadása:

function EgyediElemek(vizsgaltTomb: number[]): number {
   let egyediElemek: number[] = [];
   for (let i: number = 0; i < vizsgaltTomb.length; i++) {
      if (!egyediElemek.includes(vizsgaltTomb[i])) {
         egyediElemek.push(vizsgaltTomb[i]);
      }
   }
   return egyediElemek.length;
}



//számtömbben prím számok mennyiségének megszámolása:
function PrimekSzama(vizsgaltTomb: number[]): number {
   let primekSzama: number = 0;

   for (let i: number = 0; i < vizsgaltTomb.length; i++) {
      let osztokSzama: number = 0;
      for (let j: number = 1; j <= vizsgaltTomb[i]; j++) {
         if (vizsgaltTomb[i] % j == 0) {
            osztokSzama++;
         }
      }
      if (osztokSzama == 2) {
         primekSzama++;
      }
   }

   return primekSzama;
}
//primek száma booleannal
function PrimekSzama(vizsgaltTomb: number[]): number {
   let primekSzama: number = 0;

   for (let i: number = 0; i < vizsgaltTomb.length; i++) {
      let szam: number = vizsgaltTomb[i];
      let prim: boolean = true; // alapértelmezetten feltételezzük, hogy prím

      if (szam < 2) {
         prim = false; // 0 és 1 nem prím
      } else {
         for (let j: number = 2; j <= Math.sqrt(szam); j++) {
            if (szam % j === 0) {
               prim = false; // ha osztható, nem prím
               break; // nem kell tovább ellenőrizni
            }
         }
      }

      if (prim) {
         primekSzama++;
      }
   }

   return primekSzama;
}


//primek kiválogatása új tömbbe:
function PrimekKivalogatas(vizsgaltTomb: number[]): number[] {
   let primekTomb: number[] = [];

   for (let i: number = 0; i < vizsgaltTomb.length; i++) {
      let osztokSzama: number = 0;

      for (let j: number = 1; j <= vizsgaltTomb[i]; j++) {
         if (vizsgaltTomb[i] % j == 0) {
            osztokSzama++;
         }
      }

      if (osztokSzama == 2) {
         // ha prím, hozzáadjuk az új tömbhöz
         primekTomb.push(vizsgaltTomb[i]);
      }
   }

   return primekTomb;
}



//vizsgalt szam prim-e vagy sem boolean
  PrimE(vizsgaltSzam: number): string {
    let osztokSzama: number = 0;
    for (let i = 1; i <= vizsgaltSzam; i++) {
      if (vizsgaltSzam % i == 0) {
        osztokSzama++;
      }
    }
    if (osztokSzama == 2) {
      return `prím`;
    } else {
      return `NEM prím`;
    }
  }
  




// szerver cuccok:

elindítás:
node server.js





